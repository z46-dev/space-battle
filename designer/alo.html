<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Top-Down Exporter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #exportBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: sans-serif;
        }
    </style>
</head>

<body>
    <button id="exportBtn">Export Top-Down View</button>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
        import { OBJLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/OBJLoader.js';

        // 1. Renderer with preserveDrawingBuffer for export :contentReference[oaicite:2]{index=2}
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Scene & Lights
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202025);
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 20, 10);
        scene.add(light);

        // 3. Orthographic camera setup (top-down) :contentReference[oaicite:3]{index=3}
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 50;
        const camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2,
            0.1, 1000
        );
        camera.position.set(0, 50, 0);    // high above the origin
        camera.up.set(0, 0, -1);          // orient ‘north’ toward -Z :contentReference[oaicite:4]{index=4}
        camera.lookAt(0, 0, 0);
        scene.add(camera);

        // 4. Load Model (uncomment desired format) :contentReference[oaicite:5]{index=5}
        const loader = new GLTFLoader();
        // const loader = new OBJLoader();

        loader.load(
            // replace with your model path:
            'models/ship.gltf',
            gltf => {
                const obj = gltf.scene || gltf;  // GLTFLoader gives .scene; OBJLoader gives object directly
                obj.position.set(0, 0, 0);
                obj.rotation.x = -Math.PI / 2;   // if your model’s forward axis differs, adjust as needed
                scene.add(obj);
            },
            xhr => console.log((xhr.loaded / xhr.total * 100).toFixed(1) + '% loaded'),
            err => console.error('Model load error:', err)
        );

        // 5. Handle resizing
        window.addEventListener('resize', () => {
            const w = window.innerWidth, h = window.innerHeight;
            renderer.setSize(w, h);
            camera.left = -frustumSize * (w / h) / 2;
            camera.right = frustumSize * (w / h) / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
        });

        // 6. Render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // 7. Export button logic using canvas.toDataURL() :contentReference[oaicite:6]{index=6}
        document.getElementById('exportBtn').addEventListener('click', () => {
            const dataURL = renderer.domElement.toDataURL('image/png');
            // trigger download
            const link = document.createElement('a');
            link.download = 'top_down_view.png';
            link.href = dataURL;
            link.click();
        });
    </script>
</body>

</html>